"""Dramatiq-based job scheduler."""

import logging
from datetime import datetime, timedelta
from typing import Any, Callable, Dict, Optional
import dramatiq
from dramatiq.brokers.redis import RedisBroker
from dramatiq.middleware import CurrentMessage, Retries, TimeLimit
from dramatiq_crontab import cron
from app.core.config import settings

logger = logging.getLogger(__name__)


class DramatiqScheduler:
    """Dramatiq job scheduler."""

    def __init__(self):
        """Initialize Dramatiq scheduler."""
        redis_url = getattr(settings, 'REDIS_URL', 'redis://localhost:6379/0')

        # Configure broker
        self.broker = RedisBroker(url=redis_url)

        # Add middleware
        self.broker.add_middleware(CurrentMessage())
        self.broker.add_middleware(Retries(max_retries=3))
        self.broker.add_middleware(
            TimeLimit(time_limit=30 * 60 * 1000))  # 30 minutes

        # Set as default broker
        dramatiq.set_broker(self.broker)

        self._tasks = {}
        self._scheduled_tasks = {}

    def task(self,
             name: Optional[str] = None,
             schedule: Optional[Dict[str, Any]] = None,
             queue_name: str = "default",
             **kwargs):
        """Decorator to register a task."""
        def decorator(func: Callable):
            task_name = name or f"{func.__module__}.{func.__name__}"

            # Create Dramatiq actor
            actor = dramatiq.actor(func, queue_name=queue_name, **kwargs)

            # Store task info
            self._tasks[task_name] = {
                'func': func,
                'actor': actor,
                'schedule': schedule,
                'name': task_name,
                'queue_name': queue_name
            }

            # Handle scheduling
            if schedule:
                self._setup_scheduled_task(task_name, actor, schedule)

            return actor

        return decorator

    def _setup_scheduled_task(self, task_name: str, actor, schedule: Dict[str, Any]):
        """Setup scheduled task using dramatiq-crontab."""
        schedule_type = schedule.get('type', 'interval')

        if schedule_type == 'cron':
            cron_string = self._build_cron_string(schedule)

            @cron(cron_string)
            def scheduled_task():
                actor.send()

            self._scheduled_tasks[task_name] = scheduled_task

        elif schedule_type == 'interval':
            # For interval scheduling, we'll use a cron expression
            seconds = schedule.get('seconds', 60)
            if seconds < 60:
                # For sub-minute intervals, use * * * * * (every minute)
                # Note: This is a limitation of cron-based scheduling
                cron_string = "* * * * *"
            else:
                minutes = seconds // 60
                cron_string = f"*/{minutes} * * * *"

            @cron(cron_string)
            def scheduled_task():
                actor.send()

            self._scheduled_tasks[task_name] = scheduled_task

    def _build_cron_string(self, schedule: Dict[str, Any]) -> str:
        """Build cron string from schedule config."""
        minute = schedule.get('minute', '*')
        hour = schedule.get('hour', '*')
        day = schedule.get('day_of_month', '*')
        month = schedule.get('month_of_year', '*')
        day_of_week = schedule.get('day_of_week', '*')

        return f"{minute} {hour} {day} {month} {day_of_week}"

    def run_task(self, task_name: str, *args, **kwargs):
        """Run a task immediately."""
        if task_name in self._tasks:
            actor = self._tasks[task_name]['actor']
            message = actor.send(*args, **kwargs)
            return message.message_id
        else:
            raise ValueError(f"Task {task_name} not found")

    def schedule_task(self, task_name: str, delay=None, *args, **kwargs):
        """Schedule a task to run after a delay."""
        if task_name in self._tasks:
            actor = self._tasks[task_name]['actor']

            if delay is None:
                delay = 0
            elif isinstance(delay, datetime):
                delay = int((delay - datetime.utcnow()).total_seconds() * 1000)
            elif isinstance(delay, (int, float)):
                delay = int(delay * 1000)  # Convert to milliseconds

            message = actor.send_with_options(
                args=args,
                kwargs=kwargs,
                delay=delay
            )
            return message.message_id
        else:
            raise ValueError(f"Task {task_name} not found")

    def get_task_status(self, message_id: str):
        """Get the status of a task."""
        # Dramatiq doesn't have built-in result backend
        # You would need to implement custom result storage
        return {
            'id': message_id,
            'status': 'unknown',
            'note': 'Dramatiq requires custom result backend for status tracking'
        }

    def list_tasks(self):
        """List all registered tasks."""
        return list(self._tasks.keys())

    def list_scheduled_tasks(self):
        """List all scheduled tasks."""
        return list(self._scheduled_tasks.keys())

    def get_queue_info(self, queue_name: str = "default"):
        """Get information about a queue."""
        # This would require implementing custom queue monitoring
        return {
            'name': queue_name,
            'note': 'Queue monitoring requires custom implementation'
        }

    def start_worker(self, queues=None, **kwargs):
        """Start Dramatiq worker."""
        if queues is None:
            queues = ["default"]

        logger.info(f"Starting Dramatiq worker for queues: {queues}")
        # This would typically be done via CLI: dramatiq app.jobs.tasks
        # For programmatic start, you'd need to implement worker management
        raise NotImplementedError(
            "Use 'dramatiq app.jobs.tasks' CLI command to start workers"
        )


# Global scheduler instance
scheduler = DramatiqScheduler()

# Task decorator shortcut
task = scheduler.task
