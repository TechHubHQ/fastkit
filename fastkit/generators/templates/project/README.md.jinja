# {{ project_name }}

A FastAPI project generated by FastKit with {{ architecture }} architecture.

## Quick Start

```bash
cd {{ project_name }}
uv sync
{% if architecture == 'microservices' %}docker-compose -f docker-compose.dev.yml up{% else %}uv run uvicorn app.main:app --reload{% endif %}
```

Then visit `http://localhost:8000` to see your API in action!

## Architecture Overview

{% if architecture == 'microservices' %}
### Microservices Architecture

This project follows a microservices architecture pattern with the following structure:

```
{{ project_name }}/
|-- services/
|   |-- api-gateway/          # API Gateway service
|   |-- service-1/            # Individual microservice
|   +-- service-2/            # Individual microservice
|-- shared/                   # Shared libraries and utilities
|   |-- models/              # Common data models
|   |-- utils/               # Shared utilities
|   +-- auth/                # Authentication helpers
|-- docker-compose.yml        # Production orchestration
|-- docker-compose.dev.yml    # Development orchestration
+-- README.md
```

**Key Features:**
- API Gateway for request routing
- Independent, scalable services
- Shared libraries for common functionality
- Docker orchestration for easy deployment
- Service discovery and load balancing ready

**Getting Started:**
1. `cd {{ project_name }}`
2. `uv sync`  # Install dependencies
3. `docker-compose -f docker-compose.dev.yml up`
4. Access API Gateway at `http://localhost:8000`

{% elif architecture == 'rest-apis' %}
### REST API Service

This project follows REST API best practices with a clean, organized structure:

```
{{ project_name }}/
|-- app/
|   |-- api/
|   |   +-- v1/              # API version 1
|   |       +-- routes.py    # API endpoints
|   |-- core/                # Core configuration
|   |-- models/              # Data models
|   |-- services/            # Business logic
|   |-- repositories/        # Data access layer
|   |-- middleware/          # Custom middleware
|   |-- schemas/             # Request/Response schemas
|   |-- utils/               # Utilities and helpers
|   |-- auth/                # Authentication logic
|   |-- db/                  # Database configuration
|   |-- cache/               # Caching logic
|   +-- main.py              # Application entry point
|-- tests/                   # Test files
|-- infra/                   # Infrastructure files
+-- README.md
```

**Key Features:**
- RESTful API design
- Comprehensive error handling
- Logging and monitoring
- Authentication and authorization
- Database and caching integration
- API versioning

**Getting Started:**
1. `cd {{ project_name }}`
2. `uv sync`  # Install dependencies and create virtual environment
3. `uv run uvicorn app.main:app --reload`  # Run the development server
4. Access API at `http://localhost:8000`

{% elif architecture == 'fullstack' %}
### Fullstack Backend Application

This project provides a backend API service designed for fullstack applications:

```
{{ project_name }}/
|-- app/
|   |-- api/
|   |   +-- v1/              # API version 1
|   |       +-- routes.py    # API endpoints
|   |-- core/                # Core configuration
|   |-- models/              # Data models
|   |-- services/            # Business logic
|   |-- repositories/        # Data access layer
|   |-- middleware/          # Custom middleware
|   |-- schemas/             # Request/Response schemas
|   |-- utils/               # Utilities and helpers
|   |-- auth/                # Authentication logic
|   |-- db/                  # Database configuration
|   |-- cache/               # Caching logic
|   +-- main.py              # Application entry point
|-- tests/                   # Test files
|-- infra/                   # Infrastructure files
+-- README.md
```

**Getting Started:**

1. `cd {{ project_name }}`
2. `uv sync`  # Install dependencies and create virtual environment
3. `uv run uvicorn app.main:app --reload`  # Run the development server
4. Access API at `http://localhost:8000`

{% endif %}

## Development

### Prerequisites
- Python 3.12+
- FastAPI
- Uvicorn
{% if architecture == 'microservices' %}
- Docker and Docker Compose
{% endif %}

### Installation

```bash
# Navigate to your project
cd {{ project_name }}

# Install dependencies and create virtual environment
uv sync

# Run the application
{% if architecture == 'microservices' %}
docker-compose -f docker-compose.dev.yml up
{% else %}
uv run uvicorn app.main:app --reload
{% endif %}
```

### API Documentation

Once the application is running, you can access:
- Interactive API docs: `http://localhost:8000/docs`
- ReDoc documentation: `http://localhost:8000/redoc`
- Health check: `http://localhost:8000/health`

### Testing

```bash
# Run tests
uv run pytest

# Run tests with coverage
uv run pytest --cov=app
```

{% if include_docker -%}
## Docker Setup

This project includes Docker configuration for easy deployment and development.

### Docker Files Structure

```
infra/
+-- docker/
    |-- docker-compose.yaml      # Base configuration
    |-- docker-compose.dev.yaml  # Development environment
    +-- docker-compose.prod.yaml # Production environment
```

### Development with Docker

```bash
# Start development environment
docker-compose -f infra/docker/docker-compose.dev.yaml up

# Start in background
docker-compose -f infra/docker/docker-compose.dev.yaml up -d

# View logs
docker-compose -f infra/docker/docker-compose.dev.yaml logs -f

# Stop services
docker-compose -f infra/docker/docker-compose.dev.yaml down
```

### Production Deployment

```bash
# Build and start production environment
docker-compose -f infra/docker/docker-compose.prod.yaml up -d

# Scale services (if applicable)
docker-compose -f infra/docker/docker-compose.prod.yaml up -d --scale app=3
```

### Docker Commands

```bash
# Build image
docker build -t {{ project_name }} .

# Run container
docker run -p 8000:8000 {{ project_name }}

# Run with environment variables
docker run -p 8000:8000 -e ENVIRONMENT=production {{ project_name }}
```
{% endif -%}

{% if include_cicd -%}
## CI/CD Pipeline

This project includes GitHub Actions workflows for continuous integration and deployment.

### Workflows

- **CI Pipeline** (`.github/workflows/ci.yaml`):
  - Runs on push to main/develop branches and pull requests
  - Tests across multiple Python versions (3.11, 3.12)
  - Linting with ruff
  - Type checking with mypy
  - Security checks with bandit and safety
  - Code coverage reporting
{% if include_docker -%}
  - Docker image building and testing
{% endif -%}

- **CD Pipeline** (`.github/workflows/cd.yaml`):
  - Runs on push to main branch and version tags
  - Automated deployment to staging/production
{% if include_docker -%}
  - Docker image building and pushing to registry
{% endif -%}
  - Environment-specific deployments

### Setting Up CI/CD

**⚠️ IMPORTANT**: Before the CD pipeline can work, you must configure repository secrets.

1. **Configure Repository Secrets**:
   Go to: `Repository Settings > Secrets and variables > Actions`
   
   **Required secrets:**
{% if include_docker -%}
   - `DOCKER_USERNAME`: Your Docker Hub username
   - `DOCKER_PASSWORD`: Your Docker Hub password or access token
{% endif -%}
   
   **Optional deployment secrets** (add based on your deployment target):
   - `AWS_ACCESS_KEY_ID` & `AWS_SECRET_ACCESS_KEY` (for AWS deployments)
   - `HEROKU_API_KEY` (for Heroku deployments)
   - `KUBECONFIG` (for Kubernetes deployments)
   - `SSH_PRIVATE_KEY` & `SERVER_HOST` (for server deployments)

2. **Update Deployment Steps**: 
   Edit `.github/workflows/cd.yaml` and replace the placeholder deployment commands with your actual deployment logic.

3. **Environment Variables**: Configure environment-specific variables in GitHub repository settings

4. **Branch Protection**: Set up branch protection rules for main branch requiring CI checks

### Local CI Testing

```bash
# Run the same checks as CI locally
uv run ruff check .
uv run ruff format --check .
uv run mypy .
uv run pytest --cov={{ project_name.replace('-', '_') }}
uv run bandit -r {{ project_name.replace('-', '_') }}/
uv run safety check
```
{% endif -%}

## Project Structure Benefits

{% if architecture == 'microservices' %}
- **Scalability**: Each service can be scaled independently
- **Technology Diversity**: Different services can use different technologies
- **Team Independence**: Teams can work on different services independently
- **Fault Isolation**: Failure in one service doesn't affect others
{% elif architecture == 'rest-apis' %}
- **Simplicity**: Straightforward structure for API development
- **Best Practices**: Follows REST API conventions
- **Scalability**: Can handle high loads with proper deployment
- **Maintainability**: Clear organization of code
{% elif architecture == 'fullstack' %}
- **API-First Design**: Built specifically for frontend integration
- **Rapid Development**: Optimized structure for fullstack development
- **Flexibility**: Easy to integrate with any frontend framework
{% endif %}

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for your changes
5. Run the test suite
6. Submit a pull request

## License

This project is licensed under the MIT License.